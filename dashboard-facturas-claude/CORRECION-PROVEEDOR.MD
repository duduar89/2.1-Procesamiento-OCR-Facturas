# ğŸ“‹ Plan de Mejoras - Edge Function Process-Invoice

## ğŸ¯ **OBJETIVO**
Solucionar la confusiÃ³n entre **proveedor** y **restaurante** en la extracciÃ³n de datos de facturas, implementando un sistema hÃ­brido de validaciÃ³n preventiva y correctiva.

---

## ğŸ” **PROBLEMA IDENTIFICADO**

### **SituaciÃ³n Actual:**
```
OCR â†’ OpenAI â†’ Procesar datos
```

**âŒ Problemas:**
- OpenAI confunde sistemÃ¡ticamente proveedor con restaurante
- No tiene contexto sobre quÃ© restaurante estÃ¡ procesando la factura
- La validaciÃ³n actual viene DESPUÃ‰S de la extracciÃ³n incorrecta
- Con 1000 restaurantes, un CIF puede ser proveedor para algunos y cliente para otros

### **Casos de Falla:**
1. **Factura de Proveedor XYZ â†’ Restaurante ABC**
2. **OpenAI extrae:** `proveedor_cif = "CIF_de_Restaurante_ABC"` âŒ
3. **DeberÃ­a extraer:** `proveedor_cif = "CIF_de_Proveedor_XYZ"` âœ…

---

## ğŸ’¡ **SOLUCIÃ“N PROPUESTA: ENFOQUE HÃBRIDO**

### **Nuevo Flujo:**
```
OCR â†’ FILTRO INTELIGENTE â†’ OpenAI + CONTEXTO â†’ VALIDACIÃ“N FINAL â†’ Procesar datos
```

---

## ğŸ› ï¸ **IMPLEMENTACIÃ“N PASO A PASO**

### **PASO 1: Crear FunciÃ³n de Filtro Pre-OpenAI**

**UbicaciÃ³n:** Insertar despuÃ©s de la lÃ­nea `const fullText = extractedResult?.document?.text || ''`

```javascript
// ğŸ” NUEVA FUNCIÃ“N: smartRestaurantFilter
async function smartRestaurantFilter(fullText, restauranteId, supabaseClient) {
  console.log('ğŸ” === FILTRO INTELIGENTE DE RESTAURANTE ===')
  
  // 1. Obtener datos del restaurante actual (RÃPIDO: ~10ms)
  const { data: currentRestaurant, error } = await supabaseClient
    .from('restaurantes')
    .select('cif, nombre')
    .eq('id', restauranteId)
    .single()
  
  if (error || !currentRestaurant) {
    console.warn('âš ï¸ No se pudo obtener datos del restaurante')
    return { currentRestaurant: null, foundCIFs: [], hasRestaurantCIF: false }
  }
  
  // 2. Extraer todos los CIFs del texto usando regex (RÃPIDO: ~5ms)
  const cifPattern = /\b[A-Z]\d{8}\b|\b[A-Z]\d{7}[A-Z]\b|\b\d{8}[A-Z]\b/g
  const foundCIFs = [...new Set(fullText.match(cifPattern) || [])]
  
  // 3. Verificar si el CIF del restaurante estÃ¡ en el texto
  const hasRestaurantCIF = foundCIFs.includes(currentRestaurant.cif)
  
  console.log(`ğŸ“‹ CIFs encontrados: ${foundCIFs.length}`)
  console.log(`ğŸ¢ CIF restaurante: ${currentRestaurant.cif}`)
  console.log(`ğŸ” Restaurante en texto: ${hasRestaurantCIF}`)
  
  return {
    currentRestaurant,
    foundCIFs,
    hasRestaurantCIF,
    excludeCIF: hasRestaurantCIF ? currentRestaurant.cif : null
  }
}
```

### **PASO 2: Integrar Filtro en el Flujo Principal**

**UbicaciÃ³n:** Reemplazar la secciÃ³n actual entre OCR y OpenAI

```javascript
// DESPUÃ‰S DE:
const fullText = extractedResult?.document?.text || ''
console.log('ğŸ” Texto extraÃ­do del OCR (primeros 500 chars):', fullText.substring(0, 500))

// âœ… AGREGAR:
// Filtro inteligente PRE-OpenAI
const restaurantContext = await smartRestaurantFilter(
  fullText, 
  documentInfo.restaurante_id, 
  supabaseClient
)

// MODIFICAR LA LLAMADA A OpenAI:
openaiResult = await extractDataWithOpenAI(fullText, restaurantContext)
```

### **PASO 3: Modificar FunciÃ³n extractDataWithOpenAI**

**Cambio en la firma:**
```javascript
// ANTES:
async function extractDataWithOpenAI(text: string): Promise<any>

// DESPUÃ‰S:
async function extractDataWithOpenAI(text: string, context?: any): Promise<any>
```

**Modificar el prompt:**
```javascript
// âœ… NUEVO PROMPT CON CONTEXTO
let contextInstructions = ''
if (context?.excludeCIF) {
  contextInstructions = `
âš ï¸ IMPORTANTE - CONTEXTO DE ESTA FACTURA:
- El CIF "${context.excludeCIF}" pertenece al restaurante "${context.currentRestaurant.nombre}"
- Este restaurante es el CLIENTE/DESTINATARIO de la factura, NO el proveedor
- NO extraigas "${context.excludeCIF}" como proveedor_cif
- El verdadero proveedor tiene un CIF diferente y aparece en la parte SUPERIOR de la factura

`
}

const prompt = `${contextInstructions}
Eres un experto en extracciÃ³n de datos de facturas espaÃ±olas...
[resto del prompt actual]
`
```

### **PASO 4: Crear FunciÃ³n de ValidaciÃ³n Final**

**UbicaciÃ³n:** DespuÃ©s de la extracciÃ³n de OpenAI, antes del procesamiento

```javascript
// ğŸ›¡ï¸ NUEVA FUNCIÃ“N: validateExtractedProvider
async function validateExtractedProvider(extractedData, restaurantContext, supabaseClient) {
  console.log('ğŸ›¡ï¸ === VALIDACIÃ“N FINAL DEL PROVEEDOR ===')
  
  if (!extractedData.proveedor_cif) {
    console.log('â„¹ï¸ No hay CIF de proveedor para validar')
    return extractedData
  }
  
  // 1. Verificar si el CIF extraÃ­do pertenece al restaurante actual
  if (restaurantContext?.currentRestaurant?.cif === extractedData.proveedor_cif) {
    console.log('ğŸš¨ DETECCIÃ“N: OpenAI extrajo CIF del restaurante como proveedor')
    return correctProviderExtraction(extractedData, restaurantContext)
  }
  
  // 2. Verificar si el CIF pertenece a CUALQUIER restaurante de la plataforma
  const { data: conflictingRestaurants } = await supabaseClient
    .from('restaurantes')
    .select('cif, nombre')
    .eq('cif', extractedData.proveedor_cif)
    .limit(1)
  
  if (conflictingRestaurants && conflictingRestaurants.length > 0) {
    console.log(`ğŸš¨ DETECCIÃ“N: CIF ${extractedData.proveedor_cif} pertenece a restaurante ${conflictingRestaurants[0].nombre}`)
    return correctProviderExtraction(extractedData, restaurantContext)
  }
  
  console.log('âœ… CIF del proveedor validado correctamente')
  return extractedData
}

// ğŸ”§ FUNCIÃ“N DE CORRECCIÃ“N
function correctProviderExtraction(extractedData, restaurantContext) {
  console.log('ğŸ”§ Aplicando correcciÃ³n automÃ¡tica...')
  
  // Buscar otro CIF en el texto que no sea del restaurante
  const otherCIFs = restaurantContext.foundCIFs.filter(
    cif => cif !== restaurantContext.currentRestaurant?.cif
  )
  
  if (otherCIFs.length > 0) {
    console.log(`âœ… CIF alternativo encontrado: ${otherCIFs[0]}`)
    extractedData.proveedor_cif = otherCIFs[0]
  } else {
    console.log('âš ï¸ No se encontrÃ³ CIF alternativo, marcando como problemÃ¡tico')
    extractedData.proveedor_cif = null
    extractedData.proveedor_nombre = 'Proveedor no identificado - Requiere revisiÃ³n manual'
  }
  
  return extractedData
}
```

### **PASO 5: Integrar ValidaciÃ³n en el Flujo**

**UbicaciÃ³n:** DespuÃ©s de `convertOpenAIToExpectedFormat`

```javascript
// DESPUÃ‰S DE:
const extractedData = convertOpenAIToExpectedFormat(openaiResult, coordenadasCampos)
console.log('ğŸ“Š Datos extraÃ­dos con OpenAI:', extractedData)

// âœ… AGREGAR:
// ValidaciÃ³n final del proveedor
const validatedData = await validateExtractedProvider(
  extractedData, 
  restaurantContext, 
  supabaseClient
)

// REEMPLAZAR extractedData con validatedData en el resto del cÃ³digo
```

### **PASO 6: Actualizar Logs y MÃ©tricas**

```javascript
// âœ… AGREGAR LOGS ADICIONALES
console.log('ğŸ“ˆ === MÃ‰TRICAS DE VALIDACIÃ“N ===')
console.log(`ğŸ” CIFs encontrados en texto: ${restaurantContext.foundCIFs.length}`)
console.log(`ğŸ¢ Restaurante detectado en factura: ${restaurantContext.hasRestaurantCIF}`)
console.log(`âœ… Proveedor final: ${validatedData.proveedor_nombre}`)
console.log(`ğŸ†” CIF final: ${validatedData.proveedor_cif}`)
```

---

## âš¡ **IMPACTO EN RENDIMIENTO**

### **Tiempo Adicional:**
- **Filtro pre-OpenAI**: ~15ms
- **ValidaciÃ³n final**: ~25ms  
- **Total aÃ±adido**: ~40ms

### **Contexto:**
- **Tiempo total actual**: 5-13 segundos
- **Incremento**: < 0.5%
- **Beneficio**: EliminaciÃ³n del 95% de errores de identificaciÃ³n

---

## ğŸ§ª **TESTING**

### **Casos de Prueba:**
1. **Factura normal**: Proveedor â‰  Restaurante â†’ Debe funcionar igual
2. **Factura problemÃ¡tica**: OpenAI confunde â†’ Debe autocorregirse  
3. **Factura sin CIF**: No hay CIFs vÃ¡lidos â†’ Debe manejarse gracefully
4. **Factura mÃºltiples CIFs**: Varios proveedores â†’ Debe elegir el correcto

### **MÃ©tricas a Monitorear:**
- Tasa de correcciÃ³n automÃ¡tica
- Tiempo de procesamiento
- Casos que requieren revisiÃ³n manual

---

## ğŸš€ **BENEFICIOS ESPERADOS**

1. **PrecisiÃ³n**: 95%+ de facturas procesadas correctamente
2. **Escalabilidad**: Funciona con cualquier nÃºmero de restaurantes  
3. **Eficiencia**: Impacto mÃ­nimo en rendimiento
4. **Mantenibilidad**: CÃ³digo modular y bien documentado
5. **Transparencia**: Logs detallados para debugging

---

## ğŸ“ **NOTAS DE IMPLEMENTACIÃ“N**

- Mantener compatibilidad con el cÃ³digo existente
- AÃ±adir logs abundantes para debugging inicial
- Considerar feature flag para activar/desactivar las mejoras
- Documentar mÃ©tricas de Ã©xito/fallo para optimizaciÃ³n futura