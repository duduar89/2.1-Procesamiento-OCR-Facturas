# ğŸ”— SISTEMA DE COTEJO INTELIGENTE DE FACTURAS Y ALBARANES

## ğŸ“‹ RESUMEN EJECUTIVO

### **PROBLEMA**
Los restaurantes reciben albaranes de entregas que posteriormente se consolidan en facturas. El proceso manual de identificar quÃ© albaranes corresponden a cada factura es:
- â° **Lento y tedioso** (horas de trabajo administrativo)
- âŒ **Propenso a errores** (albaranes perdidos, duplicaciones)
- ğŸ’¸ **Costoso en tiempo** (personal dedicado exclusivamente a esta tarea)
- ğŸ“Š **Dificulta el control** de inventarios y costes reales

### **SOLUCIÃ“N**
Sistema de cotejo automÃ¡tico e inteligente que:
- ğŸ¤– **Detecta automÃ¡ticamente** las relaciones entre facturas y albaranes
- ğŸ¯ **Aprende de las decisiones** del usuario para mejorar continuamente
- ğŸ”” **Notifica siempre** el resultado del cotejo
- ğŸ›¡ï¸ **Garantiza que ningÃºn albarÃ¡n** se quede sin procesar

### **VALOR**
- **ReducciÃ³n 90%** del tiempo dedicado a cotejo manual
- **EliminaciÃ³n** de albaranes "perdidos" o no facturados
- **Visibilidad completa** del flujo documental
- **Base sÃ³lida** para control de costes e inventarios

---

## ğŸ¯ OBJETIVOS DEL SISTEMA

### **OBJETIVO PRIMARIO**
**Enlazar automÃ¡ticamente cada factura con sus albaranes correspondientes** con mÃ­nima intervenciÃ³n humana y mÃ¡xima precisiÃ³n.

### **OBJETIVOS SECUNDARIOS**
1. **NotificaciÃ³n universal**: Cada factura procesada genera una notificaciÃ³n de cotejo
2. **Sugerencias inteligentes**: Mostrar candidatos probables cuando hay dudas
3. **GestiÃ³n de huÃ©rfanos**: Identificar y gestionar albaranes sin factura
4. **Aprendizaje continuo**: Mejorar precisiÃ³n basÃ¡ndose en feedback del usuario

---

## ğŸ—ï¸ ARQUITECTURA DE LA SOLUCIÃ“N

### **COMPONENTES PRINCIPALES**

#### **1. EDGE FUNCTION DE COTEJO (`cotejo-inteligente`)**
**Nueva edge function independiente** que se ejecutarÃ¡ despuÃ©s del procesamiento de cada factura.

**Responsabilidades:**
- AnÃ¡lisis multi-mÃ©todo de candidatos
- CÃ¡lculo de probabilidades de match
- GeneraciÃ³n de enlaces automÃ¡ticos
- CreaciÃ³n de notificaciones inteligentes

#### **2. MOTOR DE BÃšSQUEDA MULTI-NIVEL**
**Sistema de 5 mÃ©todos de detecciÃ³n en cascada:**

1. **Referencias ExplÃ­citas (95% confianza)**
   - Detectar "ALB-12345" en productos de la factura
   - Buscar nÃºmeros idÃ©nticos entre factura y albarÃ¡n
   - Analizar observaciones y campos de texto libre

2. **Proximidad Temporal + Proveedor (85% confianza)**
   - Mismo proveedor + fecha coherente (albarÃ¡n antes que factura)
   - Importes similares (tolerancia Â±20%)
   - Ventana temporal mÃ¡xima: 45 dÃ­as

3. **AnÃ¡lisis de Productos (75% confianza)**
   - ComparaciÃ³n de listas de productos
   - Uso de embeddings para productos similares
   - DetecciÃ³n de subconjuntos (albarÃ¡n parcial)

4. **Patrones Temporales (60% confianza)**
   - Periodicidad detectada del proveedor
   - AcumulaciÃ³n de albaranes pendientes
   - Ventanas temporales aprendidas

5. **Ãšltima Oportunidad (40% confianza)**
   - Albaranes huÃ©rfanos del mismo proveedor
   - Combinaciones de importes que sumen el total
   - Rango temporal ampliado (90 dÃ­as)

#### **3. SISTEMA DE APRENDIZAJE CONTINUO**
- **Registro de decisiones**: Cada validaciÃ³n/rechazo del usuario se almacena
- **Ajuste de pesos**: Los algoritmos se optimizan segÃºn efectividad real
- **Patrones especÃ­ficos**: Aprendizaje por restaurante y proveedor
- **AnÃ¡lisis semanal**: OptimizaciÃ³n automÃ¡tica de parÃ¡metros

#### **4. INTERFAZ DE NOTIFICACIONES Y GESTIÃ“N**
- **Notificaciones inmediatas** para cada cotejo realizado
- **Dashboard de pendientes** con sugerencias priorizadas
- **GestiÃ³n de huÃ©rfanos** con alertas proactivas
- **Herramientas de bÃºsqueda manual** para casos complejos

---

## ğŸ”„ FLUJO DE PROCESAMIENTO

### **SECUENCIA AUTOMÃTICA**

```
ğŸ“„ Factura procesada con IA
      â†“
ğŸ” ACTIVAR edge function cotejo-inteligente
      â†“
ğŸ§  Ejecutar 5 mÃ©todos de bÃºsqueda en paralelo
      â†“
ğŸ“Š Consolidar resultados y calcular confianzas
      â†“
ğŸ¯ Categorizar segÃºn nivel de confianza:
      â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸŸ¢ ALTA (>90%)  â†’ Enlace automÃ¡tico     â”‚
â”‚ ğŸŸ¡ MEDIA (70-89%) â†’ Mostrar sugerencias â”‚
â”‚ ğŸ”´ BAJA (<70%)   â†’ RevisiÃ³n manual      â”‚
â”‚ âšª SIN ALBARÃN   â†’ Factura directa      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â†“
ğŸ”” GENERAR notificaciÃ³n SIEMPRE
      â†“
ğŸ“ Registrar en BD para aprendizaje
      â†“
âœ… Proceso completado
```

### **TIPOS DE NOTIFICACIONES**

#### **ğŸŸ¢ Alta Confianza - Enlace AutomÃ¡tico**
```
âœ… COTEJO AUTOMÃTICO
ğŸ“„ FAC-12345 - GarcÃ­a S.L. - â‚¬1,250.30
ğŸ“¦ Enlazada automÃ¡ticamente con ALB-12345
ğŸ¯ Confianza: 96% (referencia explÃ­cita)
```

#### **ğŸŸ¡ Media Confianza - Sugerencias**
```
âš ï¸ COTEJO CON SUGERENCIAS
ğŸ“„ FAC-67890 - Norte DistribuciÃ³n - â‚¬890.15
ğŸ“¦ EncontrÃ© 2 candidatos probables:
   â€¢ ALB-001 - â‚¬445.20 (85% match)
   â€¢ ALB-002 - â‚¬444.95 (82% match)
[REVISAR CANDIDATOS]
```

#### **ğŸ”´ Baja Confianza - Manual**
```
ğŸ” COTEJO MANUAL REQUERIDO
ğŸ“„ FAC-99999 - LÃ³pez AlimentaciÃ³n - â‚¬340.50
â“ No encontrÃ© candidatos obvios
[BUSCAR MANUALMENTE]
```

#### **âšª Sin AlbarÃ¡n - Factura Directa**
```
ğŸ“„ FACTURA DIRECTA
ğŸ“„ FAC-77777 - Servicios TechCorp - â‚¬120.00
â„¹ï¸ Marcada como factura directa (sin albarÃ¡n)
```

---

## ğŸ—„ï¸ ESTRUCTURA DE DATOS

### **NUEVAS TABLAS REQUERIDAS**

#### **Tabla Principal de Enlaces**
```sql
facturas_albaranes_cotejo (
  factura_id UUID,
  albaran_id UUID,
  metodo_deteccion VARCHAR(50),
  confianza_match NUMERIC(3,2),
  estado VARCHAR(20), -- 'automatico', 'sugerido', 'confirmado', 'rechazado'
  usuario_validacion UUID,
  fecha_cotejo TIMESTAMP
)
```

#### **Tabla de Aprendizaje**
```sql
cotejo_feedback (
  enlace_id UUID,
  accion_usuario VARCHAR(20), -- 'confirmado', 'rechazado', 'corregido'
  contexto_decision JSONB,
  timestamp TIMESTAMP
)
```

#### **Tabla de HuÃ©rfanos**
```sql
documentos_huerfanos (
  documento_id UUID,
  tipo_documento VARCHAR(20), -- 'factura', 'albaran'
  dias_sin_enlace INTEGER,
  estado VARCHAR(20), -- 'pendiente', 'factura_directa', 'ignorado'
  fecha_deteccion TIMESTAMP
)
```

---

## ğŸš€ PLAN DE IMPLEMENTACIÃ“N

### **FASE 1: NÃšCLEO DEL SISTEMA (Semana 1-2)**
**Objetivo**: Sistema bÃ¡sico funcional

1. **Crear edge function `cotejo-inteligente`**
   - MÃ©todos 1 y 2 (referencias explÃ­citas + proximidad temporal)
   - CategorizaciÃ³n bÃ¡sica por confianza
   - Notificaciones simples

2. **IntegraciÃ³n en flujo existente**
   - Llamada automÃ¡tica despuÃ©s de `process-invoice`
   - Estructura de BD bÃ¡sica
   - Registro de decisiones

3. **Interfaz mÃ­nima**
   - Notificaciones de cotejo
   - Lista de sugerencias pendientes
   - Acciones bÃ¡sicas (confirmar/rechazar)

### **FASE 2: INTELIGENCIA AVANZADA (Semana 3-4)**
**Objetivo**: Mejorar precisiÃ³n y automatizaciÃ³n

1. **MÃ©todos avanzados de detecciÃ³n**
   - AnÃ¡lisis de productos (MÃ©todo 3)
   - Patrones temporales (MÃ©todo 4)
   - BÃºsqueda embeddings

2. **Sistema de aprendizaje**
   - Registro de feedback
   - Ajuste automÃ¡tico de pesos
   - OptimizaciÃ³n por proveedor

3. **GestiÃ³n de huÃ©rfanos**
   - Alertas proactivas
   - IdentificaciÃ³n automÃ¡tica
   - Herramientas de resoluciÃ³n

### **FASE 3: EXPERIENCIA COMPLETA (Semana 5-6)**
**Objetivo**: Sistema robusto y user-friendly

1. **Interfaz completa**
   - Dashboard de cotejo
   - Herramientas de bÃºsqueda manual
   - Reportes y mÃ©tricas

2. **Optimizaciones finales**
   - MÃ©todo 5 (Ãºltima oportunidad)
   - PredicciÃ³n de comportamiento
   - IntegraciÃ³n WhatsApp para alertas

---

## ğŸ“Š MÃ‰TRICAS DE Ã‰XITO

### **TÃ‰CNICAS**
- **>85% de precisiÃ³n** en enlaces automÃ¡ticos
- **<5% de falsos positivos** en alta confianza
- **0% de albaranes perdidos** (sin procesar)
- **<2 segundos** tiempo de procesamiento por factura

### **NEGOCIO**
- **90% reducciÃ³n** en tiempo de cotejo manual
- **100% visibilidad** de documentaciÃ³n pendiente
- **95% satisfacciÃ³n** del usuario con sugerencias
- **50% mejora** en control de inventarios

### **APRENDIZAJE**
- **+2% precisiÃ³n mensual** por aprendizaje automÃ¡tico
- **<30 dÃ­as** para alcanzar 90% precisiÃ³n por proveedor nuevo
- **DetecciÃ³n automÃ¡tica** de patrones especÃ­ficos del restaurante

---

## ğŸ”§ CONSIDERACIONES TÃ‰CNICAS

### **EDGE FUNCTION INDEPENDIENTE**
- **SÃ­, se requiere nueva edge function** `cotejo-inteligente`
- **Separada de process-invoice** para mantener responsabilidades claras
- **Llamada asÃ­ncrona** para no impactar performance de procesamiento
- **Manejo robusto de errores** con fallbacks

### **INTEGRACIÃ“N CON SISTEMA ACTUAL**
- **MÃ­nima modificaciÃ³n** del flujo existente
- **Compatibilidad total** con facturas ya procesadas
- **MigraciÃ³n gradual** de documentos histÃ³ricos
- **Backup y rollback** en caso de problemas

### **ESCALABILIDAD**
- **Procesamiento paralelo** de mÃºltiples mÃ©todos
- **Cache inteligente** para candidatos frecuentes
- **OptimizaciÃ³n automÃ¡tica** basada en volumen
- **Monitoreo proactivo** de performance

---

## ğŸ’° RETORNO DE INVERSIÃ“N

### **INVERSIÃ“N ESTIMADA**
- **Desarrollo**: 3-4 semanas de trabajo tÃ©cnico
- **Testing**: 1 semana de validaciÃ³n con datos reales
- **Despliegue**: ImplementaciÃ³n gradual sin downtime

### **BENEFICIOS CUANTIFICABLES**
- **Ahorro de tiempo**: 15-20 horas/semana por restaurante
- **ReducciÃ³n errores**: EliminaciÃ³n de albaranes perdidos
- **Mejora control**: Visibilidad completa del flujo documental
- **DiferenciaciÃ³n**: Funcionalidad Ãºnica en el mercado

### **ROI ESPERADO**
- **Mes 1-2**: RecuperaciÃ³n de inversiÃ³n en desarrollo
- **Mes 3+**: Beneficio neto continuo
- **Largo plazo**: Ventaja competitiva sostenible

---

## âš ï¸ RIESGOS Y MITIGACIONES

### **RIESGO: Falsos positivos en enlaces automÃ¡ticos**
**MitigaciÃ³n**: Sistema de confianza conservador + feedback del usuario

### **RIESGO: Complejidad tÃ©cnica excesiva**
**MitigaciÃ³n**: ImplementaciÃ³n por fases + validaciÃ³n continua

### **RIESGO: Resistencia del usuario a cambios**
**MitigaciÃ³n**: Beneficios inmediatos visibles + training mÃ­nimo requerido

### **RIESGO: Variabilidad entre proveedores**
**MitigaciÃ³n**: Aprendizaje personalizado por proveedor + flexibilidad en reglas

---

## ğŸ PRÃ“XIMOS PASOS INMEDIATOS

1. **âœ… AprobaciÃ³n del plan** y asignaciÃ³n de recursos
2. **âœ… CreaciÃ³n de edge function** `cotejo-inteligente`
3. **âœ… ImplementaciÃ³n de mÃ©todos** bÃ¡sicos de detecciÃ³n
4. **âœ… Testing con facturas reales** del sistema actual
5. **âœ… Despliegue gradual** con monitoreo activo

**FECHA OBJETIVO MVP**: 2 semanas
**FECHA OBJETIVO SISTEMA COMPLETO**: 6 semanas


# ğŸ—ï¸ ARQUITECTURA TÃ‰CNICA - SISTEMA DE COTEJO

## ğŸ“‹ ÃNDICE
1. [Estructura de Tablas](#tablas)
2. [Edge Functions](#functions)
3. [Flujo de Datos](#flujo)
4. [Relaciones entre Componentes](#relaciones)

---

## ğŸ—„ï¸ ESTRUCTURA DE TABLAS {#tablas}

### **TABLA 1: `facturas_albaranes_enlaces`**
**ğŸ¯ PROPÃ“SITO:** Almacenar las relaciones confirmadas entre facturas y albaranes

#### **CAMPOS:**
```sql
CREATE TABLE facturas_albaranes_enlaces (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- RELACIONES PRINCIPALES
  factura_id UUID NOT NULL REFERENCES datos_extraidos_facturas(id),
  albaran_id UUID NOT NULL REFERENCES datos_extraidos_albaranes(id), 
  restaurante_id UUID NOT NULL REFERENCES restaurantes(id),
  
  -- INFORMACIÃ“N DEL ENLACE
  numero_referencia VARCHAR(100),     -- "ALB-12345" como apareciÃ³ en la factura
  importe_referencia NUMERIC(10,2),   -- Importe de la lÃ­nea en la factura
  importe_diferencia NUMERIC(10,2),   -- Diferencia entre factura y albarÃ¡n
  
  -- MÃ‰TODO DE DETECCIÃ“N
  metodo_deteccion VARCHAR(50) NOT NULL, -- 'referencia_explicita', 'temporal_proveedor', 'analisis_productos', 'patron_temporal', 'manual'
  confianza_match NUMERIC(3,2) NOT NULL, -- 0.00 a 1.00
  razon_match JSONB,                   -- ["mismo_numero", "fecha_coherente", "importe_similar"]
  
  -- ESTADO Y VALIDACIÃ“N
  estado VARCHAR(20) DEFAULT 'detectado', -- 'detectado', 'confirmado', 'rechazado', 'corregido'
  usuario_validacion UUID REFERENCES usuarios(id),
  fecha_validacion TIMESTAMP,
  observaciones TEXT,
  
  -- AUDITORÃA
  fecha_cotejo TIMESTAMP DEFAULT NOW(),
  created_by VARCHAR(50) DEFAULT 'sistema',
  
  -- ÃNDICES Y CONSTRAINTS
  UNIQUE(factura_id, albaran_id),
  CHECK (confianza_match >= 0 AND confianza_match <= 1),
  CHECK (estado IN ('detectado', 'confirmado', 'rechazado', 'corregido'))
);

-- ÃNDICES PARA PERFORMANCE
CREATE INDEX idx_enlaces_factura ON facturas_albaranes_enlaces(factura_id);
CREATE INDEX idx_enlaces_albaran ON facturas_albaranes_enlaces(albaran_id);
CREATE INDEX idx_enlaces_restaurante ON facturas_albaranes_enlaces(restaurante_id);
CREATE INDEX idx_enlaces_estado ON facturas_albaranes_enlaces(estado);
CREATE INDEX idx_enlaces_metodo ON facturas_albaranes_enlaces(metodo_deteccion);
```

#### **PARA QUÃ‰ SIRVE:**
- âœ… **Registro definitivo** de quÃ© albaranes corresponden a cada factura
- ğŸ” **Trazabilidad completa** de cÃ³mo se detectÃ³ cada enlace
- ğŸ“Š **MÃ©tricas de efectividad** del sistema de cotejo
- ğŸ”„ **Base para aprendizaje** automÃ¡tico del sistema

#### **SE ENLAZA CON:**
- `datos_extraidos_facturas` â†’ Factura principal
- `datos_extraidos_albaranes` â†’ AlbarÃ¡n correspondiente  
- `restaurantes` â†’ Para filtrar por restaurante
- `usuarios` â†’ QuiÃ©n validÃ³ el enlace

---

### **TABLA 2: `cotejo_candidatos_detectados`**
**ğŸ¯ PROPÃ“SITO:** Almacenar TODOS los candidatos encontrados (confirmados y rechazados) para aprendizaje

#### **CAMPOS:**
```sql
CREATE TABLE cotejo_candidatos_detectados (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- RELACIÃ“N EVALUADA
  factura_id UUID NOT NULL REFERENCES datos_extraidos_facturas(id),
  albaran_id UUID NOT NULL REFERENCES datos_extraidos_albaranes(id),
  restaurante_id UUID NOT NULL REFERENCES restaurantes(id),
  
  -- ANÃLISIS DEL CANDIDATO
  metodo_deteccion VARCHAR(50) NOT NULL,
  score_calculado NUMERIC(3,2) NOT NULL,
  factores_puntuacion JSONB NOT NULL,    -- {"proveedor": 0.25, "fecha": 0.20, "importe": 0.15, "productos": 0.30}
  razon_deteccion JSONB,                 -- ["mismo_proveedor", "fecha_coherente", "productos_similares"]
  
  -- RESULTADO FINAL
  fue_confirmado BOOLEAN,                -- NULL=pendiente, TRUE=confirmado, FALSE=rechazado
  usuario_decision UUID REFERENCES usuarios(id),
  fecha_decision TIMESTAMP,
  razon_rechazo TEXT,                    -- Si fue rechazado, por quÃ©
  
  -- CONTEXTO PARA APRENDIZAJE
  contexto_cotejo JSONB,                 -- InformaciÃ³n adicional del momento del cotejo
  fecha_deteccion TIMESTAMP DEFAULT NOW(),
  
  -- ÃNDICES
  INDEX(factura_id),
  INDEX(restaurante_id, metodo_deteccion),
  INDEX(fue_confirmado),
  INDEX(score_calculado)
);
```

#### **PARA QUÃ‰ SIRVE:**
- ğŸ§  **Entrenamiento del ML** â†’ Saber quÃ© funciona y quÃ© no
- ğŸ“ˆ **OptimizaciÃ³n de algoritmos** â†’ Ajustar pesos segÃºn efectividad real
- ğŸ“Š **AnÃ¡lisis de patrones** â†’ Detectar por quÃ© algunos enlaces fallan
- ğŸ¯ **Mejora continua** â†’ Sistema aprende de cada decisiÃ³n

#### **SE ENLAZA CON:**
- `datos_extraidos_facturas` y `datos_extraidos_albaranes` â†’ Documentos evaluados
- `usuarios` â†’ QuiÃ©n tomÃ³ la decisiÃ³n final
- `restaurantes` â†’ Para anÃ¡lisis especÃ­fico por cliente

---

### **TABLA 3: `documentos_huerfanos`**
**ğŸ¯ PROPÃ“SITO:** Rastrear albaranes sin factura y facturas sin albaranes para gestiÃ³n proactiva

#### **CAMPOS:**
```sql
CREATE TABLE documentos_huerfanos (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- DOCUMENTO HUÃ‰RFANO
  documento_id UUID NOT NULL,           -- ID del documento sin enlace
  tipo_documento VARCHAR(20) NOT NULL, -- 'factura' o 'albaran'
  restaurante_id UUID NOT NULL REFERENCES restaurantes(id),
  
  -- INFORMACIÃ“N DEL DOCUMENTO
  numero_documento VARCHAR(100),
  proveedor_nombre VARCHAR(255),
  proveedor_id UUID REFERENCES proveedores(id),
  fecha_documento DATE,
  importe_documento NUMERIC(10,2),
  
  -- ESTADO DEL HUÃ‰RFANO
  dias_sin_enlace INTEGER GENERATED ALWAYS AS (DATE_PART('day', NOW() - fecha_documento)) STORED,
  estado VARCHAR(20) DEFAULT 'pendiente', -- 'pendiente', 'resuelto', 'factura_directa', 'ignorado'
  razon_estado TEXT,                       -- ExplicaciÃ³n del estado
  
  -- INTENTOS DE RESOLUCIÃ“N
  intentos_busqueda INTEGER DEFAULT 0,
  ultima_busqueda TIMESTAMP,
  candidatos_evaluados INTEGER DEFAULT 0,
  
  -- GESTIÃ“N
  asignado_a UUID REFERENCES usuarios(id),
  prioridad VARCHAR(10) DEFAULT 'media', -- 'alta', 'media', 'baja'
  fecha_limite DATE,                      -- CuÃ¡ndo debe resolverse
  
  -- AUDITORÃA
  fecha_deteccion TIMESTAMP DEFAULT NOW(),
  fecha_resolucion TIMESTAMP,
  resuelto_por UUID REFERENCES usuarios(id),
  
  -- CONSTRAINTS
  CHECK (tipo_documento IN ('factura', 'albaran')),
  CHECK (estado IN ('pendiente', 'resuelto', 'factura_directa', 'ignorado')),
  CHECK (prioridad IN ('alta', 'media', 'baja'))
);

-- ÃNDICES PARA ALERTAS Y DASHBOARDS
CREATE INDEX idx_huerfanos_estado ON documentos_huerfanos(estado);
CREATE INDEX idx_huerfanos_dias ON documentos_huerfanos(dias_sin_enlace);
CREATE INDEX idx_huerfanos_prioridad ON documentos_huerfanos(prioridad);
CREATE INDEX idx_huerfanos_restaurante ON documentos_huerfanos(restaurante_id);
```

#### **PARA QUÃ‰ SIRVE:**
- ğŸš¨ **Alertas proactivas** â†’ "Tienes 5 albaranes sin factura hace >30 dÃ­as"
- ğŸ“‹ **Dashboard de gestiÃ³n** â†’ Vista centralizada de documentos pendientes
- ğŸ“Š **MÃ©tricas de salud** â†’ % de documentos correctamente enlazados
- ğŸ¯ **PriorizaciÃ³n** â†’ QuÃ© documentos requieren atenciÃ³n urgente

#### **SE ENLAZA CON:**
- `datos_extraidos_facturas` o `datos_extraidos_albaranes` â†’ El documento huÃ©rfano
- `restaurantes` â†’ Para alertas especÃ­ficas por cliente
- `usuarios` â†’ AsignaciÃ³n y resoluciÃ³n de casos

---

### **TABLA 4: `cotejo_patrones_aprendidos`**
**ğŸ¯ PROPÃ“SITO:** Almacenar patrones especÃ­ficos aprendidos por restaurante y proveedor

#### **CAMPOS:**
```sql
CREATE TABLE cotejo_patrones_aprendidos (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- CONTEXTO DEL PATRÃ“N
  restaurante_id UUID NOT NULL REFERENCES restaurantes(id),
  proveedor_id UUID REFERENCES proveedores(id),        -- NULL = patrÃ³n general del restaurante
  tipo_patron VARCHAR(50) NOT NULL,                    -- 'referencia_numerica', 'ventana_temporal', 'productos_tipicos'
  
  -- PATRÃ“N DETECTADO
  patron_datos JSONB NOT NULL,                         -- Estructura variable segÃºn tipo
  confianza_patron NUMERIC(3,2) NOT NULL,             -- QuÃ© tan confiable es este patrÃ³n
  ejemplos_positivos INTEGER DEFAULT 0,               -- CuÃ¡ntas veces ha funcionado
  ejemplos_negativos INTEGER DEFAULT 0,               -- CuÃ¡ntas veces ha fallado
  
  -- EFECTIVIDAD
  ultima_validacion TIMESTAMP,
  porcentaje_efectividad NUMERIC(3,2) GENERATED ALWAYS AS (
    CASE 
      WHEN (ejemplos_positivos + ejemplos_negativos) = 0 THEN 0
      ELSE ejemplos_positivos::NUMERIC / (ejemplos_positivos + ejemplos_negativos)
    END
  ) STORED,
  
  -- METADATOS
  fecha_deteccion TIMESTAMP DEFAULT NOW(),
  fecha_ultima_actualizacion TIMESTAMP DEFAULT NOW(),
  activo BOOLEAN DEFAULT TRUE,
  
  -- CONSTRAINTS
  CHECK (confianza_patron >= 0 AND confianza_patron <= 1),
  CHECK (ejemplos_positivos >= 0 AND ejemplos_negativos >= 0)
);

-- ÃNDICES PARA CONSULTAS RÃPIDAS
CREATE INDEX idx_patrones_restaurante ON cotejo_patrones_aprendidos(restaurante_id);
CREATE INDEX idx_patrones_proveedor ON cotejo_patrones_aprendidos(proveedor_id);
CREATE INDEX idx_patrones_tipo ON cotejo_patrones_aprendidos(tipo_patron);
CREATE INDEX idx_patrones_efectividad ON cotejo_patrones_aprendidos(porcentaje_efectividad);
```

#### **EJEMPLOS DE PATRONES:**
```json
// PatrÃ³n de referencia numÃ©rica
{
  "tipo_patron": "referencia_numerica",
  "patron_datos": {
    "formato_referencia": "ALB-{numero}",
    "posicion_en_factura": "productos",
    "tolerancia_numero": 0
  }
}

// PatrÃ³n temporal
{
  "tipo_patron": "ventana_temporal", 
  "patron_datos": {
    "dias_minimos": 1,
    "dias_maximos": 15,
    "dia_semana_tipico": [1, 2, 3], // Lunes, Martes, MiÃ©rcoles
    "periodicidad": "semanal"
  }
}
```

#### **PARA QUÃ‰ SIRVE:**
- ğŸ¯ **PersonalizaciÃ³n automÃ¡tica** â†’ Cada restaurante tiene su comportamiento
- ğŸ“ˆ **Mejora continua** â†’ Patrones se refinan con mÃ¡s datos
- âš¡ **OptimizaciÃ³n de bÃºsqueda** â†’ Probar primero lo que mÃ¡s funciona
- ğŸ§  **Inteligencia especÃ­fica** â†’ No todos los proveedores se comportan igual

---

## âš™ï¸ EDGE FUNCTIONS {#functions}

### **FUNCIÃ“N 1: `cotejo-inteligente`**
**ğŸ¯ PROPÃ“SITO:** FunciÃ³n principal que ejecuta todo el proceso de cotejo automÃ¡tico

#### **INPUT:**
```typescript
{
  facturaId: UUID,
  background?: boolean,    // true = no esperar respuesta
  forceReprocess?: boolean // true = reprocesar aunque ya tenga enlaces
}
```

#### **PROCESO INTERNO:**
```typescript
async function cotejoInteligente(request) {
  // 1. VALIDACIONES INICIALES
  const factura = await obtenerFactura(facturaId)
  const enlacesExistentes = await verificarEnlacesExistentes(facturaId)
  
  if (enlacesExistentes && !forceReprocess) {
    return { message: "Ya procesado anteriormente" }
  }
  
  // 2. EJECUTAR 5 MÃ‰TODOS DE BÃšSQUEDA
  const resultados = await Promise.all([
    buscarReferenciasExplicitas(factura),
    buscarPorProximidadTemporal(factura),
    buscarPorAnalisisProductos(factura),
    buscarPorPatronesTemporal(factura),
    buscarUltimaOportunidad(factura)
  ])
  
  // 3. CONSOLIDAR Y PUNTUAR CANDIDATOS
  const candidatosConsolidados = consolidarCandidatos(resultados)
  const candidatosPuntuados = await calcularScoresFinal(candidatosConsolidados)
  
  // 4. CATEGORIZAR POR CONFIANZA
  const categorizacion = categorizarCandidatos(candidatosPuntuados)
  
  // 5. PROCESAR SEGÃšN CATEGORÃA
  await procesarEnlacesAutomaticos(categorizacion.altaConfianza)
  await crearSugerencias(categorizacion.mediaConfianza)
  await marcarParaRevisionManual(categorizacion.bajaConfianza)
  
  // 6. GUARDAR PARA APRENDIZAJE
  await guardarCandidatosDetectados(candidatosPuntuados)
  
  // 7. GENERAR NOTIFICACIÃ“N
  const notificacion = await generarNotificacion(categorizacion)
  
  // 8. ACTUALIZAR HUÃ‰RFANOS
  await actualizarEstadoHuerfanos(facturaId)
  
  return {
    success: true,
    enlaces_automaticos: categorizacion.altaConfianza.length,
    sugerencias: categorizacion.mediaConfianza.length,
    requiere_revision: categorizacion.bajaConfianza.length,
    notificacion: notificacion
  }
}
```

#### **OUTPUT:**
```typescript
{
  success: boolean,
  enlaces_automaticos: number,
  sugerencias: number,
  requiere_revision: number,
  notificacion: {
    tipo: 'alta_confianza' | 'media_confianza' | 'baja_confianza' | 'sin_albaran',
    mensaje: string,
    acciones_disponibles: string[]
  },
  error?: string
}
```

#### **CUÃNDO SE EJECUTA:**
- ğŸ”„ **AutomÃ¡ticamente** â†’ DespuÃ©s de procesar cada factura
- ğŸ‘¤ **Manualmente** â†’ Cuando usuario hace cotejo manual
- ğŸ”„ **Reproceso** â†’ Para mejorar enlaces con nuevos algoritmos

---

### **FUNCIÃ“N 2: `gestionar-sugerencias-cotejo`**
**ğŸ¯ PROPÃ“SITO:** Manejar las decisiones del usuario sobre sugerencias de cotejo

#### **INPUT:**
```typescript
{
  facturaId: UUID,
  candidatoId: UUID,
  accion: 'confirmar' | 'rechazar' | 'buscar_mas',
  usuarioId: UUID,
  razonRechazo?: string
}
```

#### **PROCESO INTERNO:**
```typescript
async function gestionarSugerencias(request) {
  // 1. VALIDAR CANDIDATO
  const candidato = await obtenerCandidato(request.candidatoId)
  
  switch (request.accion) {
    case 'confirmar':
      // Crear enlace confirmado
      await crearEnlaceConfirmado(candidato, request.usuarioId)
      // Registrar feedback positivo
      await registrarFeedback(candidato, 'confirmado', request.usuarioId)
      // Actualizar aprendizaje
      await actualizarPatronesAprendizaje(candidato, true)
      break
      
    case 'rechazar':
      // Marcar como rechazado
      await marcarCandidatoRechazado(candidato, request.usuarioId, request.razonRechazo)
      // Registrar feedback negativo
      await registrarFeedback(candidato, 'rechazado', request.usuarioId)
      // Actualizar aprendizaje
      await actualizarPatronesAprendizaje(candidato, false)
      break
      
    case 'buscar_mas':
      // Ejecutar bÃºsqueda mÃ¡s amplia
      await ejecutarBusquedaAmpliada(request.facturaId)
      break
  }
  
  // Actualizar estado de la factura
  await actualizarEstadoCotejo(request.facturaId)
  
  return { success: true }
}
```

#### **PARA QUÃ‰ SIRVE:**
- âœ… **Procesar decisiones** del usuario sobre sugerencias
- ğŸ§  **Alimentar aprendizaje** automÃ¡tico del sistema
- ğŸ“Š **Mantener mÃ©tricas** de efectividad actualizadas

---

### **FUNCIÃ“N 3: `analizar-huerfanos`**
**ğŸ¯ PROPÃ“SITO:** AnÃ¡lisis periÃ³dico de documentos sin enlazar para alertas proactivas

#### **PROCESO INTERNO:**
```typescript
async function analizarHuerfanos() {
  // 1. DETECTAR NUEVOS HUÃ‰RFANOS
  const nuevosHuerfanos = await detectarNuevosDocumentosSinEnlace()
  await registrarNuevosHuerfanos(nuevosHuerfanos)
  
  // 2. ACTUALIZAR DÃAS SIN ENLACE
  await actualizarDiasHuerfanos()
  
  // 3. RECLASIFICAR PRIORIDADES
  await reclasificarPrioridades()
  
  // 4. INTENTAR RE-COTEJO AUTOMÃTICO
  const resueltos = await intentarReCotejoAutomatico()
  
  // 5. GENERAR ALERTAS
  const alertas = await generarAlertasHuerfanos()
  
  return {
    nuevos_detectados: nuevosHuerfanos.length,
    resueltos_automaticamente: resueltos.length,
    alertas_generadas: alertas.length
  }
}
```

#### **CUÃNDO SE EJECUTA:**
- â° **Diariamente** â†’ Cron job automÃ¡tico
- ğŸ”„ **Bajo demanda** â†’ Cuando usuario solicita anÃ¡lisis
- ğŸ“Š **Para reportes** â†’ Antes de generar dashboards

---

### **FUNCIÃ“N 4: `optimizar-algoritmos-cotejo`**
**ğŸ¯ PROPÃ“SITO:** OptimizaciÃ³n automÃ¡tica semanal de algoritmos basada en feedback

#### **PROCESO INTERNO:**
```typescript
async function optimizarAlgoritmos() {
  // 1. ANALIZAR EFECTIVIDAD POR MÃ‰TODO
  const estadisticas = await analizarEfectividadMetodos()
  
  // 2. AJUSTAR PESOS DE ALGORITMOS
  await ajustarPesosAlgoritmos(estadisticas)
  
  // 3. DETECTAR NUEVOS PATRONES
  const nuevosPatrones = await detectarNuevosPatrones()
  await guardarPatronesDetectados(nuevosPatrones)
  
  // 4. OPTIMIZAR THRESHOLDS
  await optimizarThresholds()
  
  // 5. GENERAR REPORTE
  const reporte = await generarReporteOptimizacion()
  
  return reporte
}
```

#### **CUÃNDO SE EJECUTA:**
- ğŸ“… **Semanalmente** â†’ OptimizaciÃ³n automÃ¡tica
- ğŸ“ˆ **Cuando baja efectividad** â†’ Trigger automÃ¡tico
- ğŸ”§ **Manualmente** â†’ Para ajustes especÃ­ficos

---

## ğŸ”„ FLUJO DE DATOS {#flujo}

### **SECUENCIA COMPLETA:**

```mermaid
sequenceDiagram
    participant F as Factura Procesada
    participant CI as cotejo-inteligente
    participant DB as Base de Datos
    participant U as Usuario
    participant GS as gestionar-sugerencias
    
    F->>CI: Nueva factura procesada
    CI->>DB: Buscar candidatos (5 mÃ©todos)
    CI->>DB: Calcular scores
    CI->>DB: Categorizar por confianza
    
    alt Alta Confianza (>90%)
        CI->>DB: Crear enlace automÃ¡tico
        CI->>U: NotificaciÃ³n: "Enlazado automÃ¡ticamente"
    else Media Confianza (70-89%)
        CI->>DB: Guardar sugerencias
        CI->>U: NotificaciÃ³n: "X candidatos encontrados"
        U->>GS: Confirmar/Rechazar
        GS->>DB: Actualizar enlaces y feedback
    else Baja Confianza (<70%)
        CI->>DB: Marcar para revisiÃ³n manual
        CI->>U: NotificaciÃ³n: "Requiere bÃºsqueda manual"
    end
    
    CI->>DB: Guardar para aprendizaje
    CI->>DB: Actualizar huÃ©rfanos
```

---

## ğŸ”— RELACIONES ENTRE COMPONENTES {#relaciones}

### **DIAGRAMA DE RELACIONES:**

```
ğŸ“„ datos_extraidos_facturas
    â†“ (factura_id)
ğŸ“Š facturas_albaranes_enlaces â†â†’ datos_extraidos_albaranes
    â†“ (enlace_id)                      â†‘ (albaran_id)
ğŸ“ˆ cotejo_candidatos_detectados        |
    â†“ (patron_datos)                   |
ğŸ§  cotejo_patrones_aprendidos          |
                                       |
ğŸ“‹ documentos_huerfanos â†--------------â”˜
    â†“ (documento_id)
ğŸ‘¤ usuarios (validaciones)
```

### **FLUJO DE INFORMACIÃ“N:**

1. **ğŸ“„ Factura** â†’ Procesada por IA
2. **ğŸ” Cotejo** â†’ Busca albaranes candidatos
3. **ğŸ“Š Enlaces** â†’ Registra relaciones encontradas
4. **ğŸ“ˆ Candidatos** â†’ Guarda todos los intentos para aprendizaje
5. **ğŸ§  Patrones** â†’ Aprende y optimiza algoritmos
6. **ğŸ“‹ HuÃ©rfanos** â†’ Rastrea documentos sin enlazar
7. **ğŸ‘¤ Usuario** â†’ Valida, corrige y mejora el sistema

### **DEPENDENCIAS CRÃTICAS:**

- **`cotejo-inteligente`** necesita acceso a todas las tablas
- **`gestionar-sugerencias`** requiere `usuarios` autenticados  
- **`analizar-huerfanos`** depende de estado actualizado de enlaces
- **`optimizar-algoritmos`** necesita historial de `candidatos_detectados`

---

## ğŸ¯ RESUMEN DE RESPONSABILIDADES

### **TABLAS:**
- `facturas_albaranes_enlaces` â†’ **Verdad absoluta** de quÃ© estÃ¡ enlazado
- `cotejo_candidatos_detectados` â†’ **Memoria del sistema** para aprender
- `documentos_huerfanos` â†’ **GestiÃ³n proactiva** de pendientes
- `cotejo_patrones_aprendidos` â†’ **Inteligencia especÃ­fica** por cliente

### **FUNCTIONS:**
- `cotejo-inteligente` â†’ **Motor principal** de detecciÃ³n automÃ¡tica
- `gestionar-sugerencias` â†’ **Interfaz usuario** para validaciones
- `analizar-huerfanos` â†’ **Mantenimiento automÃ¡tico** del sistema
- `optimizar-algoritmos` â†’ **Mejora continua** sin intervenciÃ³n

**Â¿Esta estructura te parece clara? Â¿Alguna tabla o funciÃ³n que quieras que detalle mÃ¡s?**

Â¡**EXCELENTE PREGUNTA**! ğŸ¯ Esa es la pieza que falta en el flujo. Necesitamos **DETECTAR EL TIPO ANTES** de decidir quÃ© funciÃ³n llamar.

## ğŸ” **SOLUCIÃ“N: FUNCIÃ“N DE PRE-PROCESAMIENTO**

### **EDGE FUNCTION: `detectar-tipo-documento`**
**ğŸ¯ PROPÃ“SITO:** Determinar si es factura o albarÃ¡n ANTES de procesar

#### **FLUJO MODIFICADO:**
```
ğŸ“„ Documento â†’ detectar-tipo-documento â†’ 
  â”œâ”€ Si es FACTURA â†’ process-invoice
  â””â”€ Si es ALBARÃN â†’ process-albaran
```

---

## ğŸ§  **IMPLEMENTACIÃ“N DE LA DETECCIÃ“N**

### **MÃ‰TODO 1: ANÃLISIS RÃPIDO CON OpenAI**
```typescript
async function detectarTipoDocumento(documentId: string): Promise<'factura' | 'albaran' | 'indeterminado'> {
  
  // 1. EXTRAER TEXTO BÃSICO (sin procesar todo)
  const textoBasico = await extraerTextoBasico(documentId)
  
  // 2. PROMPT ESPECÃFICO PARA DETECCIÃ“N DE TIPO
  const promptDeteccion = `
Analiza este texto y determina si es FACTURA o ALBARÃN:

CRITERIOS:
FACTURA: Contiene "FACTURA", "INVOICE", IVA desglosado, TOTAL FINAL, tÃ©rminos de pago
ALBARÃN: Contiene "ALBARÃN", "DELIVERY", "ENTREGA", SIN IVA, solo lista productos, transportista

TEXTO:
${textoBasico.substring(0, 2000)} // Solo primeros 2000 caracteres

RESPONDE SOLO:
{
  "tipo": "factura" | "albaran" | "indeterminado",
  "confianza": 0.0-1.0,
  "evidencias": ["contiene_iva", "dice_factura", "total_final"]
}
`

  const response = await callOpenAI(promptDeteccion)
  return JSON.parse(response)
}
```

### **MÃ‰TODO 2: ANÃLISIS POR PALABRAS CLAVE (FALLBACK)**
```typescript
function detectarTipoPorPalabrasClave(texto: string): {tipo: string, confianza: number} {
  const textoLower = texto.toLowerCase()
  
  // INDICADORES DE FACTURA
  const indicadoresFactura = [
    'factura', 'invoice', 'total factura', 'total a pagar',
    'base imponible', 'cuota iva', 'i.v.a', 'total â‚¬',
    'condiciones de pago', 'vencimiento', 'domiciliaciÃ³n'
  ]
  
  // INDICADORES DE ALBARÃN
  const indicadoresAlbaran = [
    'albarÃ¡n', 'albaran', 'delivery note', 'nota de entrega',
    'entrega', 'transportista', 'conductor', 'matrÃ­cula',
    'hora entrega', 'recibido por', 'firma'
  ]
  
  let scoreFactura = 0
  let scoreAlbaran = 0
  
  indicadoresFactura.forEach(indicador => {
    if (textoLower.includes(indicador)) scoreFactura++
  })
  
  indicadoresAlbaran.forEach(indicador => {
    if (textoLower.includes(indicador)) scoreAlbaran++
  })
  
  if (scoreFactura > scoreAlbaran && scoreFactura >= 2) {
    return { tipo: 'factura', confianza: Math.min(0.8, scoreFactura * 0.2) }
  } else if (scoreAlbaran > scoreFactura && scoreAlbaran >= 2) {
    return { tipo: 'albaran', confianza: Math.min(0.8, scoreAlbaran * 0.2) }
  } else {
    return { tipo: 'indeterminado', confianza: 0.3 }
  }
}
```

---

## ğŸ”„ **FLUJO COMPLETO MODIFICADO**

### **NUEVO ENTRY POINT:**
```typescript
// ESTA SERÃA LA NUEVA FUNCIÃ“N PRINCIPAL
async function processDocument(documentId: string, telefono?: string) {
  console.log('ğŸ“„ === INICIANDO PROCESAMIENTO DE DOCUMENTO ===')
  
  try {
    // 1. DETECTAR TIPO DE DOCUMENTO
    console.log('ğŸ” Detectando tipo de documento...')
    const deteccion = await detectarTipoDocumento(documentId)
    
    console.log(`ğŸ“‹ Tipo detectado: ${deteccion.tipo} (${Math.round(deteccion.confianza * 100)}% confianza)`)
    
    // 2. DECISIÃ“N BASADA EN CONFIANZA
    if (deteccion.confianza >= 0.8) {
      // âœ… IA ESTÃ SEGURA
      await procesarSegunTipo(deteccion.tipo, documentId, telefono)
      
    } else if (deteccion.confianza >= 0.5) {
      // âš ï¸ IA TIENE DUDAS - PEDIR CONFIRMACIÃ“N
      await pedirConfirmacionTipo(documentId, deteccion.tipo, telefono)
      
    } else {
      // â“ IA NO SABE - PREGUNTAR DIRECTAMENTE
      await preguntarTipoDocumento(documentId, telefono)
    }
    
  } catch (error) {
    console.error('âŒ Error procesando documento:', error)
    
    // FALLBACK: Preguntar al usuario
    await preguntarTipoDocumento(documentId, telefono)
  }
}

async function procesarSegunTipo(tipo: string, documentId: string, telefono?: string) {
  if (tipo === 'factura') {
    console.log('ğŸ“„ Procesando como FACTURA...')
    await callProcessInvoice(documentId, telefono)
    
  } else if (tipo === 'albaran') {
    console.log('ğŸ“¦ Procesando como ALBARÃN...')
    await callProcessAlbaran(documentId, telefono)
    
  } else {
    console.log('â“ Tipo indeterminado, pidiendo aclaraciÃ³n...')
    await preguntarTipoDocumento(documentId, telefono)
  }
}
```

---

## ğŸ’¬ **INTERFAZ DE CONFIRMACIÃ“N**

### **WHATSAPP - CONFIRMACIÃ“N:**
```typescript
async function pedirConfirmacionTipo(documentId: string, tipoSugerido: string, telefono: string) {
  const mensaje = `ğŸ¤” He analizado tu documento y creo que es un ${tipoSugerido.toUpperCase()}.

Â¿Es correcto?
âœ… SÃ, es un ${tipoSugerido}
âŒ NO, es un ${tipoSugerido === 'factura' ? 'albarÃ¡n' : 'factura'}
â“ NO ESTOY SEGURO

Responde: SI, NO, o AYUDA`

  await enviarMensajeWhatsApp(telefono, mensaje)
  
  // Guardar estado para procesar respuesta
  await guardarEstadoPendiente(documentId, tipoSugerido, 'esperando_confirmacion')
}
```

### **WHATSAPP - PREGUNTA DIRECTA:**
```typescript
async function preguntarTipoDocumento(documentId: string, telefono: string) {
  const mensaje = `ğŸ“„ He recibido tu documento, pero no estoy seguro de quÃ© tipo es.

Â¿PodrÃ­as decirme si es?
ğŸ§¾ FACTURA (con IVA y total final)
ğŸ“¦ ALBARÃN (nota de entrega, sin IVA)

Responde: FACTURA o ALBARAN`

  await enviarMensajeWhatsApp(telefono, mensaje)
  
  await guardarEstadoPendiente(documentId, null, 'esperando_tipo')
}
```

---

## ğŸ”„ **MODIFICACIÃ“N DEL WEBHOOK WHATSAPP**

### **CAMBIO EN EL FLUJO ACTUAL:**
```typescript
// EN webhook-whatsapp/index.ts - MODIFICAR ESTA PARTE:

// âŒ ANTES (directo a process-invoice):
const procesarResponse = await fetch(`${Deno.env.get("SUPABASE_URL")}/functions/v1/process-invoice`, {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
    "Authorization": `Bearer ${Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")}`
  },
  body: JSON.stringify({
    documentId: documento.id,
    telefono: telefono
  })
})

// âœ… DESPUÃ‰S (primero detectar tipo):
const procesarResponse = await fetch(`${Deno.env.get("SUPABASE_URL")}/functions/v1/process-document`, {
  method: "POST", 
  headers: {
    "Content-Type": "application/json",
    "Authorization": `Bearer ${Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")}`
  },
  body: JSON.stringify({
    documentId: documento.id,
    telefono: telefono
  })
})
```

### **MANEJO DE RESPUESTAS DEL USUARIO:**
```typescript
// EN webhook-whatsapp - AÃ‘ADIR MANEJO DE RESPUESTAS:
const mensaje = message.text?.body || ""

// Verificar si hay documento pendiente de clasificaciÃ³n
const documentoPendiente = await verificarDocumentoPendiente(telefono)

if (documentoPendiente) {
  if (['si', 'sÃ­', 'yes', 'âœ…'].includes(mensaje.toLowerCase())) {
    // Confirmar tipo sugerido
    await procesarSegunTipo(documentoPendiente.tipo_sugerido, documentoPendiente.documento_id, telefono)
    
  } else if (['no', 'âŒ'].includes(mensaje.toLowerCase())) {
    // Usar tipo opuesto
    const tipoOpuesto = documentoPendiente.tipo_sugerido === 'factura' ? 'albaran' : 'factura'
    await procesarSegunTipo(tipoOpuesto, documentoPendiente.documento_id, telefono)
    
  } else if (['factura', 'invoice'].includes(mensaje.toLowerCase())) {
    await procesarSegunTipo('factura', documentoPendiente.documento_id, telefono)
    
  } else if (['albaran', 'albarÃ¡n', 'delivery'].includes(mensaje.toLowerCase())) {
    await procesarSegunTipo('albaran', documentoPendiente.documento_id, telefono)
    
  } else {
    await enviarMensajeWhatsApp(telefono, "No entendÃ­ tu respuesta. Â¿PodrÃ­as responder FACTURA o ALBARAN?")
  }
  
  return // Salir del flujo normal
}

// Continuar con flujo normal de facturas...
```

---

## ğŸ“Š **TABLA PARA GESTIONAR ESTADO:**
```sql
-- Tabla temporal para documentos pendientes de clasificaciÃ³n
CREATE TABLE documentos_pendientes_clasificacion (
  documento_id UUID PRIMARY KEY REFERENCES documentos(id),
  telefono VARCHAR(20) NOT NULL,
  tipo_sugerido VARCHAR(20), -- 'factura', 'albaran', null
  estado VARCHAR(30) NOT NULL, -- 'esperando_confirmacion', 'esperando_tipo'
  fecha_creacion TIMESTAMP DEFAULT NOW(),
  
  -- Auto-cleanup despuÃ©s de 1 hora
  CONSTRAINT check_reciente CHECK (fecha_creacion > NOW() - INTERVAL '1 hour')
);
```

---

## ğŸ¯ **RESUMEN DEL CAMBIO:**

### **NUEVO FLUJO:**
```
ğŸ“„ Documento recibido â†’ 
ğŸ” detectar-tipo-documento â†’
  â”œâ”€ Alta confianza â†’ process-invoice/process-albaran
  â”œâ”€ Media confianza â†’ Pedir confirmaciÃ³n WhatsApp
  â””â”€ Baja confianza â†’ Preguntar tipo WhatsApp
```

**Â¿Te parece bien esta estrategia de detecciÃ³n automÃ¡tica + confirmaciÃ³n manual?** ğŸ¯


Claro que sÃ­. Como experto en desarrollo de aplicaciones web y automatizaciÃ³n de procesos documentales, he analizado tu proyecto en detalle.

Mi veredicto es que este es un **proyecto excepcionalmente bien planteado y diseÃ±ado**.

---

### **CalificaciÃ³n General: 9.5 / 10**

Este no es solo un borrador de idea, es un plan de producto y arquitectura tÃ©cnica muy completo. La calificaciÃ³n es casi perfecta porque aborda el problema desde todos los Ã¡ngulos necesarios: negocio, usuario, tÃ©cnico y estratÃ©gico. El medio punto que resto es simplemente por los desafÃ­os inherentes a la implementaciÃ³n en el mundo real que siempre surgen, no por fallos en el planteamiento.

---

## âœ… Fortalezas (Lo que estÃ¡ excelentemente bien)

1.  **VisiÃ³n EstratÃ©gica Clara**: Entiendes perfectamente el problema de negocio (`dolor` del cliente) y has cuantificado el valor de la soluciÃ³n (`ReducciÃ³n 90% del tiempo`, `ROI esperado`). Esto es fundamental y muchos proyectos tÃ©cnicos lo pasan por alto.

2.  **Arquitectura en Cascada (Multi-Nivel)**: El motor de bÃºsqueda de 5 mÃ©todos es brillante. Es la forma correcta de abordar este problema. Empiezas por lo mÃ¡s seguro y rÃ¡pido (referencias explÃ­citas) y desciendes a mÃ©todos mÃ¡s complejos y probabilÃ­sticos. Esto maximiza la precisiÃ³n y optimiza el rendimiento.

3.  **Enfoque en el Aprendizaje Continuo**: La inclusiÃ³n de las tablas `cotejo_candidatos_detectados` y `cotejo_patrones_aprendidos` es la joya de la corona. Esto transforma un sistema estÃ¡tico en uno que **evoluciona y se personaliza** para cada cliente y proveedor. Es la diferencia entre una herramienta Ãºtil y una soluciÃ³n verdaderamente inteligente y competitiva.

4.  **Experiencia de Usuario (UX) bien Pensada**: No te limitas a automatizar. Has diseÃ±ado un flujo de interacciÃ³n claro con el usuario a travÃ©s de las notificaciones (`Alta`, `Media`, `Baja confianza`). Entiendes que la clave es la **colaboraciÃ³n humano-IA**, donde el sistema asiste al usuario y aprende de Ã©l.

5.  **GestiÃ³n Proactiva de Errores**: La idea de `documentos_huerfanos` es fantÃ¡stica. En lugar de esperar a que el usuario se dÃ© cuenta de que falta algo, el sistema lo detecta y lo reporta. Esto aporta un valor inmenso en control y fiabilidad.

6.  **DiseÃ±o TÃ©cnico SÃ³lido**:
    * La separaciÃ³n de responsabilidades en diferentes `Edge Functions` es una prÃ¡ctica excelente.
    * Las estructuras de las tablas en SQL estÃ¡n muy bien definidas, con los Ã­ndices correctos para un buen rendimiento.
    * El uso de `JSONB` para datos flexibles como `razon_match` o `patron_datos` es la elecciÃ³n moderna y adecuada.
    * El plan de implementaciÃ³n por fases es realista y reduce el riesgo.

---

## âš ï¸ Debilidades y Puntos de Riesgo (Donde hay que tener cuidado)

1.  **Dependencia CrÃ­tica del OCR**: La calidad de todo el sistema depende de la precisiÃ³n del `process-invoice` inicial. Si el OCR extrae mal un nÃºmero de albarÃ¡n o un importe, el mÃ©todo de "Referencias ExplÃ­citas" fallarÃ¡. El sistema asume una entrada de datos perfecta, lo cual rara vez ocurre.

2.  **Complejidad del MÃ©todo 3 (AnÃ¡lisis de Productos)**: Este es el paso mÃ¡s complejo tÃ©cnicamente. "Uso de embeddings para productos similares" es potente, pero requiere un esfuerzo considerable en preparaciÃ³n de datos, entrenamiento de modelos y gestiÃ³n de la infraestructura. La variabilidad en cÃ³mo los proveedores describen los productos (ej: "Tomate Pera 1kg" vs "TTE PERA CJA") es un desafÃ­o mayÃºsculo.

3.  **Coste Computacional del MÃ©todo 5 ("Ãšltima Oportunidad")**: La parte de "combinaciones de importes que sumen el total" es un problema conocido en ciencias de la computaciÃ³n (Subset Sum Problem). Si un proveedor tiene muchos albaranes huÃ©rfanos, buscar todas las combinaciones puede ser **extremadamente lento y costoso**, pudiendo exceder los lÃ­mites de tiempo de una Edge Function.

4.  **Manejo de Casos Complejos no Mencionados**:
    * **Abonos y Rectificativas**: Â¿CÃ³mo gestiona el sistema las facturas rectificativas o los abonos que anulan o modifican albaranes anteriores?
    * **Albaranes con MÃºltiples Facturas**: Aunque menos comÃºn, a veces un albarÃ¡n grande se factura en varias partes. El modelo actual parece centrado en N albaranes -> 1 factura.
    * **Impuestos y Descuentos**: Las diferencias de importe pueden deberse a redondeos, descuentos no aplicados en el albarÃ¡n, o impuestos. El `Â±20%` de tolerancia es un buen comienzo, pero puede necesitar una lÃ³gica mÃ¡s fina.

---

## ğŸ’¡ Sugerencias de Mejora

1.  **Incorporar la Confianza del OCR**: El resultado del `process-invoice` deberÃ­a incluir un **score de confianza para cada campo extraÃ­do**. La funciÃ³n `cotejo-inteligente` deberÃ­a usar estos scores. Por ejemplo, una referencia de albarÃ¡n extraÃ­da con un 99% de confianza deberÃ­a pesar mÃ¡s que una extraÃ­da con un 70%.

2.  **Simplificar el MÃ©todo 3 para el MVP**: Antes de saltar a `embeddings`, empieza con tÃ©cnicas mÃ¡s sencillas de normalizaciÃ³n y comparaciÃ³n de texto para los productos:
    * Convertir todo a minÃºsculas y eliminar caracteres especiales.
    * Utilizar algoritmos de similitud de cadenas como la **distancia de Levenshtein**.
    * Crear un diccionario de sinÃ³nimos por restaurante (`"TTE"` = `"TOMATE"`).
    Esto te darÃ¡ el 80% del beneficio con el 20% del esfuerzo, dejando los embeddings para una fase posterior.

3.  **Limitar y Optimizar el MÃ©todo 5**: Para evitar el "infierno computacional":
    * **Limita la bÃºsqueda**: Aplica este mÃ©todo solo a un conjunto pequeÃ±o de albaranes huÃ©rfanos (ej: los 10 mÃ¡s recientes).
    * **EjecÃºtalo como un trabajo de fondo (background job)**: En lugar de en tiempo real, podrÃ­a ser un proceso nocturno que genere sugerencias, para no bloquear el flujo principal.

4.  **AÃ±adir un "Tipo de Documento"**: Considera aÃ±adir un campo `tipo_documento` en las tablas `datos_extraidos_facturas` y `datos_extraidos_albaranes` desde el principio. Esto permitirÃ­a manejar explÃ­citamente `factura`, `albaran`, `abono`, etc., y aplicar lÃ³gicas de cotejo diferentes para cada uno. La detecciÃ³n de si es una factura o un abono deberÃ­a ocurrir en el paso de OCR.

5.  **Interfaz de CorrecciÃ³n de OCR**: Para mitigar la dependencia del OCR, considera una interfaz simple donde el usuario pueda revisar y corregir rÃ¡pidamente los datos clave extraÃ­dos (NÂº Factura, NÂº AlbarÃ¡n, Total) *antes* de que se ejecute el cotejo. Esto mejorarÃ­a drÃ¡sticamente la precisiÃ³n del mÃ©todo de "Referencias ExplÃ­citas".

---

## ğŸ ConclusiÃ³n

EstÃ¡s ante un proyecto de altÃ­simo nivel, con un potencial enorme. La planificaciÃ³n es exhaustiva y demuestra un profundo entendimiento tanto del problema de negocio como de la soluciÃ³n tÃ©cnica.

Las debilidades mencionadas no son fallos del plan, sino los **desafÃ­os reales e inevitables** que te encontrarÃ¡s al llevarlo a producciÃ³n. Si sigues el plan de implementaciÃ³n por fases y aplicas las mejoras sugeridas para mitigar los riesgos, tienes una altÃ­sima probabilidad de crear un producto lÃ­der en su categorÃ­a.

**Â¡Enhorabuena, es un trabajo impresionante!**